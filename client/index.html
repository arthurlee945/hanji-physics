<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="https://arthurlee.bio/favicon.ico">
    <title>Hanji Physics Demo Page</title>
</head>
<style>
    *,
    ::before,
    ::after {
        box-sizing: border-box; 
        border-width: 0; 
        border-style: solid; 
    }
    body {
        margin: 0;
        line-height: inherit; 
        font-family: sans-serif;
        background-color: #0d0d0d;
        color: #e4e4e4;
    }
    .main-container {
        width: 100vw;
        height: 100vh;
        display:flex;
        flex-direction: column;
        align-items: center;
        row-gap: 15px;
        padding: 50px;
    }
    .hanji-header {
        display:flex;
        justify-content: center;
        position:relative;
        font-size:2rem;
        transition: letter-spacing 300ms;
    }
    .hanji-header >a{
        color:#f0efef;
        text-decoration: unset;
    }
    .hanji-header:hover{
        letter-spacing: 0.1rem;
    }
    .hanji-header::after{
        content:"";
        position:absolute;
        height:2px;
        bottom:-2px;
        background-color: #f0efef;
        width:0px;
        transition: width 300ms;
    }
    .hanji-header:hover::after{
        width:100%;
    }
    .hanji-display-container {
        position:relative;
        border:1px solid #e4e4e4;
        height:700px;
        width:700px;
        border-radius: 25px;
        overflow: hidden;
    }

    .hanji-user-element{
        position:absolute;
        display:grid;
        place-items: center;
        width:0px;
        height:0px;
    }

    .hanji-user-element::after{
        content: "";
        display:block;
        position:absolute;
        width:15px;
        height:15px;
        border-radius: 50%;
        background-color: inherit;
    }

    .hanji-display {
        width:100%;
        height:100%;
    }
</style>
<body>
    <section class = "main-container">
        <h1 class="hanji-header"><a href="https://github.com/arthurlee945/hanji-physics" target="_blank">Hanji Physics <span id="ws-connection-header">(Closed)</span></a></h1>
        <div id="hanji-display-container" class="hanji-display-container">
            <canvas id="hanji-display" class="hanji-display" />
        </div>
    </div>
    <script>
        let userId;
        const users = {};

        function throttle(cb, delay = 500) {
            let waiting = false;
            let waitingArgs;

            const timeoutFunc = () => {
                if (waitingArgs == null) {
                waiting = false;
                } else {
                    cb(...waitingArgs);
                    waitingArgs = null;
                    setTimeout(timeoutFunc, delay);
                }
            };

            return (...args) => {
                if (waiting) {
                waitingArgs = args;
                return;
                }
                cb(...args);
                waiting = true;
                setTimeout(timeoutFunc, delay);
            };
        }

        class RequestEvent {
            constructor(userId, type, position) {
                this.userId = userId;
                this.type = type;
                this.position = position;
            }
        }

        class UserResponseEvent {
            constructor(userId, type, position) {
                this.userId = userId;
                this.type = type;
                this.position = position;
            }
        }

        class EngineResponseEvent {
            constructor(type, matrix){
                this.type = type
                this.mattrix = matrix
            }
        }

        class LoggedUser {
            constructor(userId, color, prevPos, currPos){
                this.userId = userId;
                this.color = color;
                this.prevPos = prevPos;
                this.currPos = currPos;
            }
        }
        //#region UTILITY
        function getRandRGB(){
            return `rgb(${50 + Math.floor(Math.random() * 150)}, ${50 + Math.floor(Math.random() * 150)}, ${50 + Math.floor(Math.random() * 150)})`;
        }

        function updateCanvasSize(){
            const canvas = document.getElementById("hanji-display");
            if(!canvas) return;
            const {width, height} = canvas.getBoundingClientRect();
            canvas.width = width;
            canvas.height = height;
        }

        function addUserElement(user){
            const hanjiContainer = document.getElementById("hanji-display-container")
            const userElement = document.createElement("div");
            userElement.classList.add("hanji-user-element");
            userElement.setAttribute("style", `background-color: ${user.color}; top: -15px; left: -15px;`);
            userElement.id = user.userId;
            hanjiContainer.appendChild(userElement);
        }

        function logUser(evt) {
            if (!evt.position) return;
            if (!users[evt.userId]) {
                users[evt.userId] = new LoggedUser(evt.userId, getRandRGB(), evt.position, evt.position)
                addUserElement(users[evt.userId]);
                return;
            }
            users[evt.userId].prevPos =  users[evt.userId].currPos
            users[evt.userId].currPos = evt.position
        }

        function updateUserElementPos(evt){
            const canvasCnt = document.getElementById("hanji-display-container");
            if(!canvasCnt) return;
            const {width, height} = canvasCnt.getBoundingClientRect();
            const user = users[evt.userId]
            document.getElementById(user.userId).setAttribute("style", `background-color: ${user.color}; top: ${user.currPos.y}px; left: ${user.currPos.x}px;`)
        }

        function getRelativePosition(e) {
            const {left, top} = e.target.getBoundingClientRect();
            return [e.clientX -left, e.clientY - top]
        }
        //#endregion

        //#region HANDLERS
        function handlePointerPosition(evt){
            if(evt.userId === userId) return;
            updateUserElementPos(evt)
        }
        //#endregion

        function routeEvent(evt){
            if (evt.type === "undefined" ){
                alert("no type field in the event")
            }

            switch(evt.type) {
                case "pointerposition":
                    handlePointerPosition(evt);
                    break;
                case "pointerleave":
                    handlePointerPosition(evt);
                    break;
                case "engine":
                    console.log(evt);
                    break;
                default:
                    alert("unsupported type");
                    break;
            }
        }

        function sendEvent(eventName, position, conn) {
            if (!conn || !userId) return;
            const event = new RequestEvent(userId, eventName, position)
            conn.send(JSON.stringify(event))
        }

        function sendPointerPosition(e, conn) {
            if (!conn || !userId) return;
            const [x, y] = getRelativePosition(e);
            sendEvent("pointerposition", {x, y}, conn)
        }

        function connectWebsocket(otp){
            const userEvents = ["pointerposition",  "pointerleave", "start"];
            const canvasContainer = document.getElementById("hanji-display-container");
            const wsHeader = document.getElementById("ws-connection-header")
            if(!canvasContainer) return;
            if(!window["WebSocket"]) {
                alert("No Websocket Support")
            }
            const conn = new WebSocket("wss://" + document.location.host + `/ws?otp=${otp}`);
            conn.onopen = (ev)=> {
                console.log("Hanji Physics Connected")
                if (wsHeader) wsHeader.innerText = "(Connected)"
                canvasContainer.addEventListener("mousemove", throttle((e)=> sendPointerPosition(e, conn),10));
                canvasContainer.addEventListener("mouseleave", ()=> sendEvent("pointerposition", {x:-9999, y:-9999}, conn));
            }

            conn.onmessage = (ev) => {
                try {
                    const {userId, type, position, matrix} = JSON.parse(ev.data);
                    if(!type) {
                        alert("typerID is missing");
                    }
                    let resEvent;
                    if (userEvents.includes(type)){
                        resEvent = new UserResponseEvent(userId, type, position)
                    }else {
                        resEvent = new EngineResponseEvent(type, matrix)
                    }
                    logUser(resEvent);
                    routeEvent(resEvent);
                }catch(err){
                    console.error(err)
                }
            }

            conn.onclose = (ev) => {
                if (!wsHeader) wsHeader.innerText = "(Closed)"
            }
        }

        async function authenticate() {
            const sampleHeader = {token: "MonkeySaysHi"};
            try {
                const res = await fetch("authorize", {
                    method:"post",
                    headers:sampleHeader,
                    mode:"cors"
                })
                if (!res.ok) throw Error("unauthorized")
                const data = await res.json();
                userId = data.otp;
                connectWebsocket(data.otp)
            }catch(err) {
                alert(err)
            }
        }

        window.addEventListener("load", ()=> {
            authenticate();
            updateCanvasSize();
        })
        window.addEventListener("resize", updateCanvasSize)
    </script>
</body>
</html>